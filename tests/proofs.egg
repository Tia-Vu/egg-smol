(datatype Math
    (Add Math Math)
    (Sub Math Math)
    (Const Rational)
    (Var String))


(datatype AstMath
  (AstAdd AstMath AstMath)
  (AstSub AstMath AstMath)
  (AstConst Rational)
  (AstVar String))

(datatype Op
  (OpAdd) (OpSub) (OpConst) (OpVar))


(datatype ProofList)

;; There are two types of proofs:
;; 1) Provenance proofs justify the existance of a term 
;; 2) Equality proofs prove two terms are equal 
;; Equality proofs `a = b` also double as
;; provenance proofs `a` and `b`
;; When a proof `a = b` is used as a provenance proof, it is a proof of `b`
(datatype Proof
  ;; proves that a term exists in the database
  (Original AstMath)
  ;; justifies the fact that a rule fired
  (Rule ProofList String)
  ;; using a rule justification,
  ;; proves a term exists
  (RuleTerm Proof AstMath)
  ;; using a rule justification, proves two terms are equal
  (RuleEquality Proof AstMath AstMath)

  ;; given proofs for x1 = x2, x2 = x3, ..., xn = xn+1
  ;; proves that x1 = xn+1 and x1 and xn+1 exist
  (Transitivity ProofList)
  ;; given x1 = x2, proves x2 = x1
  (Flip Proof)
  ;; given a proof for a term t1, proves that t1 is equal
  ;; to another term t2 via equality proofs on their children
  (Congruence Proof ProofList)
  ;; a placeholder for a proof of equality between two
  ;; terms which can be proven equal using the graph
  ;; stored in the `Eq` relation
  (DemandEq AstMath AstMath :cost 10000000))

;; ProofList definitions
(function Cons (Proof ProofList) ProofList)
(function Null () ProofList)

;; prove two terms equal
(relation EqGraph (AstMath AstMath Proof))

;; For every Add in the database,
;; store a AstAdd representative
;; and a proof of that representative
(relation AddRep (Math Math AstMath Proof))
(relation SubRep (Math Math AstMath Proof))
(relation ConstRep (Rational AstMath Proof))
(relation VarRep (String AstMath Proof))

;; get children of terms
(function Child1 (AstMath) AstMath :cost 100000)
(function Child2 (AstMath) AstMath :cost 100000)

;; ############################## NORMAL RULES

(rule ((= t (Add a b))
       (AddRep a b term proof))
      ((union (Add a b) (Add (Add a b) (Const (rational 0 1))))
       (AddRep (Add a b) (Const (rational 0 1))
               (AstAdd term (AstConst (rational 0 1)))
               (RuleTerm
                   (Rule (Cons proof
                            (Null))
                          "add-identity")
                   (AstAdd term (AstConst (rational 0 1)))))
                   
        (EqGraph term (AstAdd term (AstConst (rational 0 1)))
            (RuleEquality
                (Rule (Cons proof
                            (Null))
                          "add-identity")
                term
                (AstAdd term (AstConst (rational 0 1)))))
        (EqGraph (AstAdd term (AstConst (rational 0 1))) term
            (Flip
            (RuleEquality
                (Rule (Cons proof
                            (Null))
                          "add-identity")
                term
                (AstAdd term (AstConst (rational 0 1))))))))

(rule ((= t (Add a b)) ;; (rewrite (Add a b) (Add b c))
       (AddRep a b term proof)
       (= c1 (Child1 term))
       (= c2 (Child2 term)))
      ((union (Add a b) (Add b a)) ;; normal rhs
       (AddRep b a (AstAdd c2 c1) ;; provenance
                   (RuleTerm
                       (Rule (Cons proof
                                (Null))
                          "add-commute")
                       (AstAdd c2 c1)))
       (EqGraph term (AstAdd c2 c1) ;; equality edge ->
           (RuleEquality
             (Rule (Cons proof
                       (Null))
                        "add-commute")
             (AstAdd c1 c2)
             (AstAdd c2 c1)))
       (EqGraph (AstAdd c2 c1) term ;; equality edge ->
           (Flip 
           (RuleEquality
             (Rule (Cons proof
                       (Null))
                        "add-commute")
             (AstAdd c1 c2)
             (AstAdd c2 c1))))))

; (rewrite (Add a (Add b c)) (Add (Add a b) c))
;; this rule is giant because we don't have let
;; in the rhs of rules
;; mostly we prove (Rule ...) for the rule firing
(rule ((= t (Add a (Add b c)))
       (AddRep a (Add b c) term proof)
       (= c1 (Child1 term))
       (= c2 (Child2 term))
       (AddRep b c c2term proof-right)
       (= c2termc1 (Child1 c2term))
       (= c2termc2 (Child2 c2term)))
      ((union (Add a (Add b c)) (Add (Add a b) c))
       ;; first, add our new representative to the graph via congruence
       (EqGraph term
           (AstAdd c1 c2term)
           (Congruence
             proof
             (Cons 
                (DemandEq c1 c1)
                (Cons
                  (DemandEq c2 c2term)
                    (Null)))))
       (EqGraph 
           (AstAdd c1 c2term)
           term
           (Flip
           (Congruence
             proof
             (Cons 
                (DemandEq c1 c1)
                (Cons
                  (DemandEq c2 c2term)
                    (Null))))))
       
       ;; Add a proof for our RHS
       (AddRep (Add a b) c
               (AstAdd (AstAdd c1 c2termc1)
                       c2termc2)
               ;; use the same proof with the rule application
               (RuleTerm
                (Rule 
                  (Cons
                    (Congruence
                      proof
                      (Cons 
                          (DemandEq c1 c1)
                          (Cons
                            (DemandEq c2 c2term)
                              (Null))))
                    (Null))
                  "add-assoc")
                (AstAdd (AstAdd c1 c2termc1)
                        c2termc2)))

      ;; prove equality between new representative and the RHS 
      (EqGraph (AstAdd c1 c2term)
               (AstAdd (AstAdd c1 c2termc1)
                        c2termc2)
               (RuleEquality
                 (Rule 
                  (Cons
                    (Congruence
                      proof
                      (Cons 
                          (DemandEq c1 c1)
                          (Cons
                            (DemandEq c2 c2term)
                              (Null))))
                    (Null))
                  "add-assoc")
                 (AstAdd c1 c2term)
                  (AstAdd (AstAdd c1 c2termc1)
                            c2termc2)))

      (EqGraph (AstAdd (AstAdd c1 c2termc1)
                        c2termc2)
               (AstAdd c1 c2term)
               (Flip
               (RuleEquality
                 (Rule 
                  (Cons
                    (Congruence
                      proof
                      (Cons 
                          (DemandEq c1 c1)
                          (Cons
                            (DemandEq c2 c2term)
                              (Null))))
                    (Null))
                  "add-assoc")
                 (AstAdd c1 c2term)
                  (AstAdd (AstAdd c1 c2termc1)
                            c2termc2))))
      ))

(add-ruleset rules)
(clear-rules)


;; ########################## PROOF RULES

;; children
(rule ((= a (AstAdd c1 c2)))
      ((set (Child1 a) c1)
       (set (Child2 a) c2)))
(rule ((= a (AstSub c1 c2)))
      ((set (Child1 a) c1)
       (set (Child2 a) c2)))


;; make a connection when an add node is represented
;; in two different ways
(rule ((AddRep a b t1 p1)
       (AddRep a b t2 p2)
       (!= t1 t2)
       (= a1 (Child1 t1))
       (= a2 (Child2 t1))
       (= b1 (Child1 t2))
       (= b2 (Child2 t2))
       )
      ((delete (AddRep a b t2 p2))
       (EqGraph t1 t2 (Congruence
                   p1
                   (Cons (DemandEq a1 b1)
                         (Cons (DemandEq b1 b2)
                               (Null)))))
       (EqGraph t2 t1
                (Flip
                (Congruence
                   p1
                   (Cons (DemandEq a1 b1)
                         (Cons (DemandEq b1 b2)
                               (Null))))))
       ))

(rule ((SubRep a b t1 p1)
       (SubRep a b t2 p2)
       (!= t1 t2)
       (= a1 (Child1 t1))
       (= a2 (Child2 t1))
       (= b1 (Child1 t2))
       (= b2 (Child2 t2))
       )
      ((delete (SubRep a b t2 p2))
       (EqGraph t1 t2 (Congruence
                   p1
                   (Cons (DemandEq a1 b1)
                         (Cons (DemandEq b1 b2)
                               (Null)))))
       (EqGraph t2 t1
                (Flip
                (Congruence
                   p1
                   (Cons (DemandEq a1 b1)
                         (Cons (DemandEq b1 b2)
                               (Null))))))
       ))

(rule ((VarRep a t1 p1)
       (VarRep a t2 p2)
       (!= t1 t2)
       )
      ((panic "Variables should have a unique representation")))
(rule ((ConstRep a t1 p1)
       (ConstRep a t2 p2)
       (!= t1 t2))
      ((panic "Constants should have a unique representation")))

(add-ruleset proof-rules)
(clear-rules)



;; Silly function since the proofs are relations
(function GetProof (AstMath) Proof :cost 1000000000)
(rule ((AddRep a b term proof))
      ((set (GetProof term) proof)))
(rule ((SubRep a b term proof))
      ((set (GetProof term) proof)))
(rule ((ConstRep a term proof))
      ((set (GetProof term) proof)))
(rule ((VarRep a term proof))
      ((set (GetProof term) proof)))

;; start term, end term, current progress term, proof
(function ProofBetween (AstMath AstMath AstMath) ProofList :cost 100000 :merge old)

;; start proof search for equalities
(rule ((= e (DemandEq t1 t2)))
      ((set (ProofBetween t1 t2 t1) (Null))))
;; do one step of proof search to find a path
(rule ((= proof (ProofBetween t1 t2 tmid))
       (EqGraph tmid next eproof))
      ((set (ProofBetween t1 t2 next)
            (Cons eproof proof))))
;; when you find a path, union it with the equality proof
(rule ((= e (DemandEq t1 t2))
       (= prooflist (ProofBetween t1 t2 t2)))
      ((set (DemandEq t1 t2) (Transitivity prooflist))))

(add-ruleset proof-extract)
(clear-rules)


(define two (rational 2 1))
(define start1 (Add (Var "x") (Const two)))
;; add original proofs
(VarRep "x" (AstVar "x") (Original (AstVar "x")))
(ConstRep two (AstConst two) (Original (AstConst two)))
(define addx2 (AstAdd (AstVar "x") (AstConst two)))
(define add2x (AstAdd (AstConst two) (AstVar "x")))
(AddRep (Var "x") (Const two)
        addx2
        (Original (AstAdd (AstVar "x") (AstConst two))))


(load-ruleset proof-rules)
(run 1000)
(clear-rules)

(load-ruleset rules)
(run 1)
(clear-rules)
(load-ruleset proof-rules)
(run 1000)
(clear-rules)

(load-ruleset rules)
(run 1)
(clear-rules)
(load-ruleset proof-rules)
(run 1000)
(clear-rules)

(load-ruleset rules)
(run 1)
(clear-rules)
(load-ruleset proof-rules)
(run 1000)
(clear-rules)


(define zero (AstConst (rational 0 1)))
(define addzero (AstAdd addx2 zero))
(define addzerofront (AstAdd (AstAdd zero (AstVar "x")) (AstConst two)))

(DemandEq addx2 add2x)
(DemandEq addx2 addzerofront)

(load-ruleset proof-extract)
(run 100)
(clear-rules)

(check (= (Add (Var "x") (Const two))
          (Add (Const two) (Var "x"))))
(check
  (= (GetProof (AstAdd (AstVar "x") (AstConst two)))
     (Original (AstAdd (AstVar "x") (AstConst two)))))

(check
  (= (GetProof add2x)
     (RuleTerm
       (Rule (Cons (Original addx2) (Null))"add-commute")
       add2x
       )))

(check (= (DemandEq addx2 add2x)
          (Transitivity
            (Cons
              (RuleEquality
                (Rule (Cons (Original addx2) (Null))"add-commute")
                addx2
                add2x)
              (Null)))))


(check (= (DemandEq addx2 addzero)
          (Transitivity
            (Cons
              (RuleEquality
                (Rule
                  (Cons
                    (Original addx2) (Null)) "add-identity")
                addx2
                addzero)
              (Null)))))

(check (= (DemandEq addx2 addzerofront)
          (Transitivity
            (Cons
              ;; 0+(x+2) -> (0+x)+2
              (RuleEquality
                ;; proof that the assoc rule fires
                (Rule
                  (Cons
                   (Congruence 
                     ;; proof of 0+(x+2)
                     (RuleTerm
                      (Rule (Cons (RuleTerm (Rule (Cons (Original (addx2)) (Null)) "add-identity") (addzero)) (Null)) "add-commute")
                     (AstAdd (zero) (addx2)))
                    
                     ;; children already equal
                     (Cons (Transitivity (Null)) (Cons (Transitivity (Null)) (Null))))
                   (Null)) "add-assoc")
                (AstAdd (zero) (addx2)) (addzerofront))
              
              
              ;; (x+2)+0 -> 0+(x+2)
              (Cons
                (RuleEquality
                  (Rule (Cons (RuleTerm (Rule (Cons (Original (addx2)) (Null)) "add-identity") (addzero)) (Null)) "add-commute")
                  
                  (addzero)
                  
                  (AstAdd (zero) (addx2)))
              
              ;; x+2 -> (x+2)+0
              (Cons (RuleEquality
                      (Rule (Cons (Original (addx2)) (Null)) "add-identity")
                      (addx2)
                      (addzero))
              
              (Null))))
          )))