(datatype Math
  (Num Rational) 
  (Var String) 
  (Fma Math Math Math) 
  (If Math Math Math) 
  (Less Math Math) 
  (Greater Math Math) 
  (Eq Math Math) 
  (NotEq Math Math) 
  (Add Math Math) 
  (Sub Math Math) 
  (Mul Math Math) 
  (Div Math Math) 
  (Not Math) 
  (Neg Math) 
  (Log Math) 
  (Exp Math) 
  (Sin Math) 
  (Cos Math) 
  (Tan Math) 
  (Atan Math) 
  (Expm1 Math) 
  (E))

(datatype AstMath
  (NumAst Rational) 
  (VarAst String) 
  (FmaAst AstMath AstMath AstMath) 
  (IfAst AstMath AstMath AstMath) 
  (LessAst AstMath AstMath) 
  (GreaterAst AstMath AstMath) 
  (EqAst AstMath AstMath) 
  (NotEqAst AstMath AstMath) 
  (AddAst AstMath AstMath) 
  (SubAst AstMath AstMath) 
  (MulAst AstMath AstMath) 
  (DivAst AstMath AstMath) 
  (NotAst AstMath) 
  (NegAst AstMath) 
  (LogAst AstMath) 
  (ExpAst AstMath) 
  (SinAst AstMath) 
  (CosAst AstMath) 
  (TanAst AstMath) 
  (AtanAst AstMath) 
  (Expm1Ast AstMath) 
  (EAst))

(datatype ProofList)

(datatype Proof
  ;; Terms that are originally inserted into the database
  (Original AstMath)
  ;; Multi is a single rule application with a list of proofs for the necessary arguments
  (Multi ProofList String)
  ;; Trasitiviis a proof between two terms, from the last item to the most recent
  (TransitiviProofList)
  ;; Congruence provides a proof between two terms using proofs of equalities between their children
  (Congruence ProofList)
  ;; Two numbers are the same
  (Refl Rational)
  ;; Equaliis a placeholder- during proof extraction, a proof for the equaliis computed
  ;; by finding a path between the two terms
  (Equality AstMath AstMath :cost 10000000))

(function Cons (Proof ProofList) ProofList)
(function Null () ProofList)

(datatype TrmPrf
  (Pair AstMath Proof))

(function Pi1 (TrmPrf) AstMath)  
(function Pi2 (TrmPrf) Proof)  

(rewrite (Pi1 (Pair t p)) t)
(rewrite (Pi2 (Pair t p)) p)

(relation EqProof (AstMath AstMath Proof))

(function Child1 (AstMath) AstMath)
(function Child2 (AstMath) AstMath)
(function Child3 (AstMath) AstMath)

(relation NumRep (Rational AstMath Proof))
(relation VarRep (String AstMath Proof))

; We do not need to worry about redundant proofs of a specific number
(function NumRep_ (Rational) TrmPrf :merge old)
(function VarRep_ (String) TrmPrf :merge old)

(relation FmaRep (Math Math Math AstMath Proof))
(function FmaRep_ (Math Math Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let y1 (Child2 t1))
  (let z1 (Child3 t1))
  (let x2 (Child1 t2))
  (let y2 (Child2 t2))
  (let z2 (Child3 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) (Cons (Equality z1 z2) Null)))))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)
(relation IfRep (Math Math Math AstMath Proof))
(function IfRep_ (Math Math Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let y1 (Child2 t1))
  (let z1 (Child3 t1))
  (let x2 (Child1 t2))
  (let y2 (Child2 t2))
  (let z2 (Child3 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) (Cons (Equality z1 z2) Null)))))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)

(relation NotEqRep (Math Math AstMath Proof))
(function NotEqRep_ (Math Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let y1 (Child2 t1))
  (let x2 (Child1 t2))
  (let y2 (Child2 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)

(relation AddRep (Math Math AstMath Proof))
(function AddRep_ (Math Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let t2 (Pi1 new))
  (let x1 (Child1 t1))
  (let y1 (Child2 t1))
  (let x2 (Child1 t2))
  (let y2 (Child2 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)

(relation SubRep (Math Math AstMath Proof))
(function SubRep_ (Math Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let y1 (Child2 t1))
  (let x2 (Child1 t2))
  (let y2 (Child2 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)

(relation MulRep (Math Math AstMath Proof))
(function MulRep_ (Math Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let y1 (Child2 t1))
  (let x2 (Child1 t2))
  (let y2 (Child2 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)

(relation DivRep (Math Math AstMath Proof))
(function DivRep_ (Math Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let y1 (Child2 t1))
  (let x2 (Child1 t2))
  (let y2 (Child2 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)

(relation NegRep (Math AstMath Proof))
(function NegRep_ (Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let x2 (Child1 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) Null)))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)
(relation ExpRep (Math AstMath Proof))
(function ExpRep_ (Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let x2 (Child1 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) Null)))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)
(relation Expm1Rep (Math AstMath Proof))
(function Expm1Rep_ (Math) TrmPrf :on_merge (
  (let t1 (Pi1 old))
  (let p1 (Pi2 old))
  (let t2 (Pi1 new))
  (let p2 (Pi2 new))
  (let x1 (Child1 t1))
  (let x2 (Child1 t2))
  (let cong-prf (Congruence (Cons (Equality x1 x2) Null)))
  (EqProof t1 t2 cong-prf)
  (EqProof t2 t1 cong-prf)
) :merge old)

; Not used in the ruleset either
; (relation EqRep (Math Math AstMath Proof))
; (relation ERep (AstMath Proof))
; (relation TanRep (Math AstMath Proof))
; (relation SinRep (Math AstMath Proof))
; (relation CosRep (Math AstMath Proof))
; (relation NotRep (Math AstMath Proof))
; (relation LogRep (Math AstMath Proof))
; (relation LessRep (Math Math AstMath Proof))
; (relation GreaterRep (Math Math AstMath Proof))
; (relation AtanRep (Math AstMath Proof))

;; prove two terms equal


(define r-zero (rational 0 1))
(define r-one (rational 1 1))
(define r-two (rational 2 1))
(define r-three (rational 3 1))
(define r-four (rational 4 1))
(define r-neg-one (rational -1 1))
(relation universe (Math))
(relation unsound (Rational Rational))
(rule ((= t (Expm1 a))) ((universe t)))
; TODO: remove, and use 'unsound' and proof reconstruction to get trace
(rule ((= (Num n) (Num m)) (!= n m)) ((panic "Unsoundness detected!")))
(rule ((= (Num n) (Num m)) (!= n m)) ((unsound n m)))

(rule ((= a (Expm1Ast x))) ((set (Child1 a) x)))
(rule ((= a (NegAst x))) ((set (Child1 a) x)))
(rule ((= a (SubAst x y))) ((set (Child1 a) x) (set (Child2 a) y)))
(rule ((= a (AddAst x y))) ((set (Child1 a) x) (set (Child2 a) y)))
(rule ((= a (MulAst x y))) ((set (Child1 a) x) (set (Child2 a) y)))
(rule ((= a (DivAst x y))) ((set (Child1 a) x) (set (Child2 a) y)))
(rule ((= a (IfAst c t f))) ((set (Child1 a) c) (set (Child2 a) t) (set (Child3 a) f)))
(rule ((= a (FmaAst x y z))) ((set (Child1 a) x) (set (Child2 a) y) (set (Child3 a) z)))

; (rewrite (Mul a b) (Mul b a))
; (rule ((= t (Mul a b))
;        (MulRep a b term proof)
;        (= c1 (Child1 term))
;        (= c2 (Child2 term)))
;       ((union (Mul a b) (Mul b a))
;        (MulRep b a (MulAst c2 c1)
;                    (Multi (Cons proof (Null)) "mul-comm"))
;        (EqProof term (MulAst c2 c1) (Multi (Cons proof (Null)) "mul-comm"))
;        (EqProof (MulAst c2 c1) term (Multi (Cons proof (Null)) "mul-comm"))))
       
; template using "conguence baked in"       
(rule ((= t (Mul a b))
       (= (Pair term proof) (MulRep_ a b))
       (= c1 (Child1 term))
       (= c2 (Child2 term)))
      ((union (Mul a b) (Mul b a))
       (let prov (Multi (Cons proof (Null)) "mul-comm"))
       (let rhs (MulAst c2 c1))
       (set (MulRep_ b a) (Pair rhs prov))
       (EqProof term rhs prov)
       (EqProof rhs term prov)))
       

; (rewrite (Sub x x) (Num r-zero))
; (rule ((= t (Sub x x))
;        (SubRep x x term proof))
;       ((union t (Num r-zero))
;        (NumRep r-zero (NumAst r-zero) (Multi (Cons proof (Null)) "x-x=0"))
;        (EqProof term (NumAst r-zero) (Multi (Cons proof (Null)) "x-x=0"))
;        (EqProof (NumAst r-zero) term (Multi (Cons proof (Null)) "x-x=0"))))
       
(rule ((= t (Sub x x))
       (= (Pair term proof) (SubRep_ x x)))
      ((union t (Num r-zero))
       (let prf (Multi (Cons proof (Null)) "x-x=0"))
       (set (NumRep_ r-zero) (Pair (NumAst r-zero) prf))
       (EqProof term (NumAst r-zero) prf)
       (EqProof (NumAst r-zero) term prf)))
       

; (rewrite (Mul x (Num r-one)) x)
; (rule ((= t (Mul x (Num r-one)))
;        (MulRep x (Num r-one) term proof)
;        (= c1 (Child1 term)))
;       ((union t x)
;        (EqProof term c1 (Multi (Cons proof (Null)) "1x=x"))
;        (EqProof c1 term (Multi (Cons proof (Null)) "1x=x"))))

(rule ((= t (Mul x (Num r-one)))
       (= (Pair term proof) (MulRep_ x (Num r-one)))
       (= c1 (Child1 term)))
      ((union t x)
       (let prf (Multi (Cons proof (Null)) "1x=x"))
       (EqProof term c1 prf)
       (EqProof c1 term prf)))

; (rewrite (Div x (Num r-one)) x)
; (rule ((= t (Div x (Num r-one)))
;        (DivRep x (Num r-one) term proof)
;        (= c1 (Child1 term)))
;       ((union t x)
;        (EqProof term c1 (Multi (Cons proof (Null)) "x/1=x"))
;        (EqProof c1 term (Multi (Cons proof (Null)) "x/1=x"))))

(rule ((= t (Div x (Num r-one)))
       (= (Pair term proof) (DivRep_ x (Num r-one)))
       (= c1 (Child1 term)))
      ((union t x)
       (let prf (Multi (Cons proof (Null)) "x/1=x"))
       (EqProof term c1 prf)
       (EqProof c1 term prf)))

; (rewrite (Neg x) (Sub (Num r-zero) x))
; (rule ((= t (Neg x))
;        (NegRep x term proof)
;        (= c1 (Child1 term)))
;       ((union t (Sub (Num r-zero) x))
;        (NumRep r-zero (NumAst r-zero) (Multi (Cons proof (Null)) "-x=0-x"))
;        (SubRep (Num r-zero) x (SubAst (NumAst r-zero) c1) (Multi (Cons proof (Null)) "-x=0-x"))
;        (EqProof term (SubAst (NumAst r-zero) c1) (Multi (Cons proof (Null)) "-x=0-x"))
;        (EqProof (SubAst (NumAst r-zero) c1) term (Multi (Cons proof (Null)) "-x=0-x"))))

(rule ((= t (Neg x))
       (= (Pair term proof) (NegRep_ x))
       (= c1 (Child1 term)))
      ((union t (Sub (Num r-zero) x))
       (let prf (Multi (Cons proof (Null)) "-x=0-x"))
       (let res (SubAst (NumAst r-zero) c1))
       (set (NumRep_ r-zero) (Pair (NumAst r-zero) prf))
       (set (SubRep_ (Num r-zero) x) (Pair res prf))
       (EqProof term res prf)
       (EqProof res term prf)))

; (rewrite (Neg x) (Mul (Num r-neg-one) x))
; (rule ((= t (Neg x))
;        (NegRep x term proof)
;        (= c1 (Child1 term)))
;       ((union t (Mul (Num r-neg-one) x))
;        (NumRep r-neg-one (NumAst r-neg-one) (Multi (Cons proof (Null)) "-x=-1*x"))
;        (MulRep (Num r-neg-one) x (MulAst (NumAst r-neg-one) c1) (Multi (Cons proof (Null)) "-x=-1*x"))
;        (EqProof term (MulAst (NumAst r-neg-one) c1) (Multi (Cons proof (Null)) "-x=-1*x"))
;        (EqProof (MulAst (NumAst r-neg-one) c1) term (Multi (Cons proof (Null)) "-x=-1*x"))))

(rule ((= t (Neg x))
       (= (Pair term proof) (NegRep_ x))
       (= c1 (Child1 term)))
      ((union t (Mul (Num r-neg-one) x))
       (let prf (Multi (Cons proof (Null)) "-x=-1*x"))
       (set (NumRep_ r-neg-one) (Pair (NumAst r-neg-one) prf))
       (let res (MulAst (NumAst r-neg-one) c1))
       (set (MulRep_ (Num r-neg-one) x) (Pair res prf))
       (EqProof term res prf)
       (EqProof res term prf)))

; The minimizer ruled out all writes to universe other than Expm1
; (rule ((universe t)) ((union t (Mul (Num r-one) t))))
; becomes
; (rewrite (Expm1 x) (Mul (Num r-one) (Expm1 x)))
; (rule ((= t (Expm1 x))
;        (Expm1Rep x term proof)
;        (= x-ast (Child1 term)))
;       ((union t (Mul (Num r-one) t))
;        (NumRep r-one (NumAst r-one)
;         (Multi (Cons proof (Null)) "e^x-1=1*(e^x-1)"))
;        (MulRep (Num r-one) t (MulAst (NumAst r-one) term)
;         (Multi (Cons proof (Null)) "e^x-1=1*(e^x-1)"))
;        (EqProof term (MulAst (NumAst r-one) term)
;         (Multi (Cons proof (Null)) "e^x-1=1*(e^x-1)"))
;        (EqProof (MulAst (NumAst r-one) term) term 
;         (Multi (Cons proof (Null)) "e^x-1=1*(e^x-1)"))))

(rule ((= t (Expm1 x))
       (= (Pair term proof) (Expm1Rep_ x))
       (= x-ast (Child1 term)))
      ((union t (Mul (Num r-one) t))
       (let prf (Multi (Cons proof (Null)) "e^x-1=1*(e^x-1)"))
       (set (NumRep_ r-one) (Pair (NumAst r-one) prf))
       (let res (MulAst (NumAst r-one) term))
       (set (MulRep_ (Num r-one) t) (Pair res prf))
       (EqProof term res prf)
       (EqProof res term prf)))

; (rewrite (Div (Sub a b) c) (Sub (Div a c) (Div b c)))
; (rule ((= x (Sub a b))
;        (SubRep a b sterm sproof)
;        (= a-ast (Child1 sterm))
;        (= b-ast (Child2 sterm))
;        (= t (Div x c))
;        (DivRep x c dterm dproof)
;        ; sterm?
;        (= x-ast (Child1 dterm))
;        (= c-ast (Child2 dterm)))
;       ((union t (Sub (Div a c) (Div b c)))
;        (DivRep a c (DivAst a-ast c-ast) (Multi (Cons sproof (Cons dproof (Null))) "(a-b)/c=a/c-b/c"))
;        (DivRep b c (DivAst b-ast c-ast) (Multi (Cons sproof (Cons dproof (Null))) "(a-b)/c=a/c-b/c"))
;        (SubRep (Div a c) (Div b c) (SubAst (DivAst a-ast c-ast) (DivAst b-ast c-ast))
;         (Multi (Cons sproof (Cons dproof (Null))) "(a-b)/c=a/c-b/c"))
;        (EqProof dterm (SubAst (DivAst a-ast c-ast) (DivAst b-ast c-ast))
;         (Multi (Cons sproof (Cons dproof (Null))) "(a-b)/c=a/c-b/c"))
;        (EqProof (SubAst (DivAst a-ast c-ast) (DivAst b-ast c-ast)) dterm
;         (Multi (Cons sproof (Cons dproof (Null))) "(a-b)/c=a/c-b/c"))))

(rule ((= x (Sub a b))
       (= (Pair sterm sproof) (SubRep_ a b))
       (= a-ast (Child1 sterm))
       (= b-ast (Child2 sterm))
       (= t (Div x c))
       (= (Pair dterm dproof) (DivRep_ x c))
       ; sterm?
       (= x-ast (Child1 dterm))
       (= c-ast (Child2 dterm)))
      ((union t (Sub (Div a c) (Div b c)))
       (let prf (Multi (Cons sproof (Cons dproof (Null))) "(a-b)/c=a/c-b/c"))
       (set (DivRep_ a c) (Pair (DivAst a-ast c-ast) prf))
       (set (DivRep_ b c) (Pair (DivAst b-ast c-ast) prf))
       (let res (SubAst (DivAst a-ast c-ast) (DivAst b-ast c-ast)))
       (set (SubRep_ (Div a c) (Div b c)) (Pair res prf))
       (EqProof dterm res prf)
       (EqProof res dterm prf)))

; (rewrite (Div (Mul a b) (Mul c d)) ;; not defined if c or d is zero
;          (Mul (Div a c) (Div b d)))

; (rule ((= m-ab (Mul a b))
;        (MulRep a b m-ab-term m-ab-proof)
;        (= m-cd (Mul c d))
;        (MulRep c d m-cd-term m-cd-proof)
;        (= t    (Div m-ab m-cd))
;        (DivRep m-ab m-cd t-term t-proof)
;        (= a-ast (Child1 m-ab-term))
;        (= b-ast (Child2 m-ab-term))
;        (= c-ast (Child1 m-cd-term))
;        (= d-ast (Child2 m-cd-term)))
;       ((union t (Mul (Div a c) (Div b d)))
;        (DivRep a c (DivAst a-ast c-ast) 
;          (Multi (Cons m-ab-proof (Cons m-cd-proof (Cons t-proof (Null)))) "ab/cd=a/c * b/d"))
;        (DivRep b d (DivAst b-ast d-ast) 
;          (Multi (Cons m-ab-proof (Cons m-cd-proof (Cons t-proof (Null)))) "ab/cd=a/c * b/d"))
;        (MulRep (Div a c) (Div b d) (MulAst (DivAst a-ast c-ast) (DivAst b-ast d-ast))
;          (Multi (Cons m-ab-proof (Cons m-cd-proof (Cons t-proof (Null)))) "ab/cd=a/c * b/d"))
;        (EqProof t-term (MulAst (DivAst a-ast c-ast) (DivAst b-ast d-ast))
;          (Multi (Cons m-ab-proof (Cons m-cd-proof (Cons t-proof (Null)))) "ab/cd=a/c * b/d"))
;        (EqProof (MulAst (DivAst a-ast c-ast) (DivAst b-ast d-ast)) t-term
;          (Multi (Cons m-ab-proof (Cons m-cd-proof (Cons t-proof (Null)))) "ab/cd=a/c * b/d"))))

(rule ((= m-ab (Mul a b))
       (= (Pair m-ab-term m-ab-proof) (MulRep_ a b))
       (= m-cd (Mul c d))
       (= (Pair m-cd-term m-cd-proof) (MulRep_ c d))
       (= t    (Div m-ab m-cd))
       (= (Pair t-term t-proof) (DivRep_ m-ab m-cd))
       (= a-ast (Child1 m-ab-term))
       (= b-ast (Child2 m-ab-term))
       (= c-ast (Child1 m-cd-term))
       (= d-ast (Child2 m-cd-term)))
      ((union t (Mul (Div a c) (Div b d)))
       (let prf 
        (Multi (Cons m-ab-proof (Cons m-cd-proof (Cons t-proof (Null)))) "ab/cd=a/c * b/d"))
       (set (DivRep_ a c) (Pair (DivAst a-ast c-ast) prf))
       (set (DivRep_ b d) (Pair (DivAst b-ast d-ast) prf))
       (let res (MulAst (DivAst a-ast c-ast) (DivAst b-ast d-ast)))
       (set (MulRep_ (Div a c) (Div b d)) (Pair res prf))
       (EqProof t-term res prf)
       (EqProof res t-term prf)))

;; errors if a or b errors
; (rewrite (Add a b)
;          (If 
;              (NotEq (Sub a b) (Num r-zero)) ;; errors if a or b errors
;              (Div
;                   (Sub (Mul a a) (Mul b b))
;                   (Sub a b))
;              (Add a b)))
; (rule ((= t (Add a b))          
;        (AddRep a b term proof)
;        (= a-ast (Child1 term))
;        (= b-ast (Child2 term)))
;       ((union t (If (NotEq (Sub a b) (Num r-zero))
;                     (Div (Sub (Mul a a) (Mul b b)) (Sub a b))
;                     (Add a b)))
; 
;        (SubRep a b (SubAst a-ast b-ast)
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (NumRep r-zero (NumAst r-zero)
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (NotEqRep (Sub a b) (Num r-zero) (NotEqAst (SubAst a-ast b-ast) (NumAst r-zero))
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (MulRep a a (MulAst a-ast a-ast)
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (MulRep b b (MulAst b-ast b-ast)
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (SubRep a b (SubAst a-ast b-ast)
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (SubRep (Mul a a) (Mul b b) (SubAst (MulAst a-ast a-ast) (MulAst b-ast b-ast))
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (DivRep (Sub (Mul a a) (Mul b b)) (Sub a b) (DivAst (SubAst (MulAst a-ast a-ast) (MulAst b-ast b-ast))
;                                                            (SubAst a-ast b-ast))
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (AddRep a b (AddAst a-ast b-ast)
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;        (IfRep (NotEq (Sub a b) (Num r-zero))
;               (Div (Sub (Mul a a) (Mul b b)) (Sub a b))
;               (Add a b)
;               (IfAst (NotEqAst (SubAst a-ast b-ast) (NumAst r-zero))
;                      (DivAst (SubAst (MulAst a-ast a-ast) (MulAst b-ast b-ast)) (SubAst a-ast b-ast))
;                      (AddAst a-ast b-ast))
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;       
;       (EqProof term (IfAst (NotEqAst (SubAst a-ast b-ast) (NumAst r-zero))
;                      (DivAst (SubAst (MulAst a-ast a-ast) (MulAst b-ast b-ast)) (SubAst a-ast b-ast))
;                      (AddAst a-ast b-ast))
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
;       (EqProof (IfAst (NotEqAst (SubAst a-ast b-ast) (NumAst r-zero))
;                      (DivAst (SubAst (MulAst a-ast a-ast) (MulAst b-ast b-ast)) (SubAst a-ast b-ast))
;                      (AddAst a-ast b-ast)) term
;         (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))))

(rule ((= t (Add a b))          
       (= (Pair term proof) (AddRep_ a b))
       (= a-ast (Child1 term))
       (= b-ast (Child2 term)))
      ((union t (If (NotEq (Sub a b) (Num r-zero))
                    (Div (Sub (Mul a a) (Mul b b)) (Sub a b))
                    (Add a b)))
       (let prf (Multi (Cons proof (Null)) "a+b=if(a-b != 0, a*a-b*b/(a-b), a+b)"))
       (set (SubRep_ a b) (Pair (SubAst a-ast b-ast) prf))
       (set (NumRep_ r-zero) (Pair (NumAst r-zero) prf))
       (let ne-ast (NotEqAst (SubAst a-ast b-ast) (NumAst r-zero)))
       (set (NotEqRep_ (Sub a b) (Num r-zero)) (Pair ne-ast prf))
       (set (MulRep_ a a) (Pair (MulAst a-ast a-ast) prf))
       (set (MulRep_ b b) (Pair (MulAst b-ast b-ast) prf))
       (set (SubRep_ a b) (Pair (SubAst a-ast b-ast) prf))
       (let sub-sq-ast (SubAst (MulAst a-ast a-ast) (MulAst b-ast b-ast)))
       (set (SubRep_ (Mul a a) (Mul b b)) (Pair sub-sq-ast prf))
       (let sub-sq-div-ast (DivAst sub-sq-ast (SubAst a-ast b-ast)))
       (set (DivRep_ (Sub (Mul a a) (Mul b b)) (Sub a b)) (Pair sub-sq-div-ast prf))
       (set (AddRep_ a b) (Pair (AddAst a-ast b-ast) prf))
       (let res (IfAst ne-ast sub-sq-div-ast (AddAst a-ast b-ast)))
       (set (IfRep_ (NotEq (Sub a b) (Num r-zero)) (Div (Sub (Mul a a) (Mul b b)) (Sub a b)) (Add a b))
            (Pair res prf))
       (EqProof term res prf)
       (EqProof res term prf)))



; (rewrite (Sub (Div a b) (Div c d)) ;; errors when b = 0 or d = 0
;          (Div (Sub (Mul a d) (Mul b c))
;                  (Mul b d))) ;; errors when b = 0 or d = 0

; (rule ((= d-ab (Div a b))
;        (DivRep a b d-ab-ast d-ab-proof)
;        (= d-cd (Div c d))
;        (DivRep c d d-cd-ast d-cd-proof)
;        (= t (Sub d-ab d-cd))
;        (SubRep d-ab d-cd term term-proof)
;        (= a-ast (Child1 d-ab-ast))
;        (= b-ast (Child2 d-ab-ast))
;        (= c-ast (Child1 d-cd-ast))
;        (= d-ast (Child2 d-cd-ast)))
;       ((union t (Div (Sub (Mul a d) (Mul b c)) (Mul b d)))
;        (MulRep a d (MulAst a-ast d-ast)
;          (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))
;        (MulRep b c (MulAst b-ast c-ast)
;          (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))
;        (MulRep b d (MulAst b-ast d-ast)
;          (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))
;        (SubRep (Mul a d) (Mul b c) (SubAst (MulAst a-ast d-ast) (MulAst b-ast c-ast))
;          (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))
;        (DivRep (Sub (Mul a d) (Mul b c)) (Mul b d) (DivAst (SubAst (MulAst a-ast d-ast) (MulAst b-ast c-ast)) (MulAst b-ast d-ast))
;          (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))
;        (EqProof term (DivAst (SubAst (MulAst a-ast d-ast) (MulAst b-ast c-ast)) (MulAst b-ast d-ast))
;          (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))
;        (EqProof (DivAst (SubAst (MulAst a-ast d-ast) (MulAst b-ast c-ast)) (MulAst b-ast d-ast)) term
;          (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))))

(rule ((= d-ab (Div a b))
       (= (Pair d-ab-ast d-ab-proof) (DivRep_ a b))
       (= d-cd (Div c d))
       (= (Pair d-cd-ast- d-cd-proof) (DivRep_ c d))
       (= t (Sub d-ab d-cd))
       (= (Pair term term-proof) (SubRep_ d-ab d-cd))
       (= a-ast (Child1 d-ab-ast))
       (= b-ast (Child2 d-ab-ast))
       (= c-ast (Child1 d-cd-ast))
       (= d-ast (Child2 d-cd-ast)))
      ((union t (Div (Sub (Mul a d) (Mul b c)) (Mul b d)))
       (let prf (Multi (Cons d-ab-proof (Cons d-cd-proof (Cons term-proof (Null)))) "a/b-c/d=(ad-bc)/bd"))
       (set (MulRep_ a d) (Pair (MulAst a-ast d-ast) prf))
       (set (MulRep_ b c) (Pair (MulAst b-ast c-ast) prf))
       (set (MulRep_ b d) (Pair (MulAst b-ast d-ast) prf))
       (let sub-mul (Sub (Mul a d) (Mul b c)))
       (let sub-mul-ast (SubAst (MulAst a-ast d-ast) (MulAst b-ast c-ast)))
       (set (SubRep_ (Mul a d) (Mul b c)) (Pair sub-mul-ast prf))
       (let div-sub-mul (Div sub-mul (Mul b d)))
       (let res (DivAst sub-mul-ast (MulAst b-ast d-ast)))
       (set (DivRep_ sub-mul (Mul b d)) (Pair res prf))
       (EqProof term res prf)
       (EqProof res term prf)))



; (rewrite (Sub (Mul x y) z)
;          (Fma x y (Neg z)))
; (rule ((= m-xy (Mul x y))         
;        (MulRep x y m-xy-ast m-xy-proof)
;        (= t (Sub m-xy z))
;        (SubRep m-xy z term proof)
;        (= x-ast (Child1 m-xy-ast))
;        (= y-ast (Child2 m-xy-ast))
;        (= z-ast (Child2 term)))
;       ((union t (Fma x y (Neg z)))
;        (NegRep z (NegAst z-ast)
;         (Multi (Cons m-xy-proof (Cons proof (Null))) "xy-z=fma(x, y, -z)"))
;        (FmaRep x y (Neg z) (FmaAst x-ast y-ast (NegAst z-ast))
;         (Multi (Cons m-xy-proof (Cons proof (Null))) "xy-z=fma(x, y, -z)"))
;        (EqProof term (FmaAst x-ast y-ast (NegAst z-ast))
;         (Multi (Cons m-xy-proof (Cons proof (Null))) "xy-z=fma(x, y, -z)"))
;        (EqProof (FmaAst x-ast y-ast (NegAst z-ast)) term 
;         (Multi (Cons m-xy-proof (Cons proof (Null))) "xy-z=fma(x, y, -z)"))))

(rule ((= m-xy (Mul x y))         
       (= (Pair m-xy-ast m-xy-proof) (MulRep_ x y))
       (= t (Sub m-xy z))
       (= (Pair term proof) (SubRep_ m-xy z))
       (= x-ast (Child1 m-xy-ast))
       (= y-ast (Child2 m-xy-ast))
       (= z-ast (Child2 term)))
      ((union t (Fma x y (Neg z)))
       (let prf (Multi (Cons m-xy-proof (Cons proof (Null))) "xy-z=fma(x, y, -z)"))
       (set (NegRep_ z) (Pair (NegAst z-ast) prf))
       (let res (FmaAst x-ast y-ast (NegAst z-ast)))
       (set (FmaRep_ x y (Neg z)) (Pair res prf))
       (EqProof term res prf)
       (EqProof res term prf)))

; (rewrite (Expm1 x)
;          (Sub (Exp x) (Num r-one)))
; (rule ((= exp-x (Expm1 x))
;        (Expm1Rep x exp-x-ast exp-x-proof)
;        (= x-ast (Child1 exp-x-ast)))
;       ((union exp-x (Sub (Exp x) (Num r-one)))
;        (NumRep r-one (NumAst r-one)
;         (Multi (Cons exp-x-proof (Null)) "(expm1 x)=e^x-1"))
;        (ExpRep x (ExpAst x-ast)
;         (Multi (Cons exp-x-proof (Null)) "(expm1 x)=e^x-1"))
;        (SubRep (Exp x) (Num r-one) (SubAst (ExpAst x-ast) (NumAst r-one))
;         (Multi (Cons exp-x-proof (Null)) "(expm1 x)=e^x-1"))
;        (EqProof exp-x-ast (SubAst (ExpAst x-ast) (NumAst r-one))
;         (Multi (Cons exp-x-proof (Null)) "(expm1 x)=e^x-1"))
;        (EqProof (SubAst (ExpAst x-ast) (NumAst r-one)) exp-x-ast
;         (Multi (Cons exp-x-proof (Null)) "(expm1 x)=e^x-1"))))

(rule ((= exp-x (Expm1 x))
       (= (Pair exp-x-ast exp-x-proof) (Expm1Rep_ x))
       (= x-ast (Child1 exp-x-ast)))
      ((union exp-x (Sub (Exp x) (Num r-one)))
       (let prf (Multi (Cons exp-x-proof (Null)) "(expm1 x)=e^x-1"))
       (set (NumRep_ r-one) (Pair (NumAst r-one) prf))
       (set (ExpRep_ x) (Pair (ExpAst x-ast) prf))
       (let res (SubAst (ExpAst x-ast) (NumAst r-one)))
       (set (SubRep_ (Exp x) (Num r-one)) (Pair res prf))
       (EqProof exp-x-ast res prf)
       (EqProof res exp-x-ast prf)))

;; Congruence

(rule ((NumRep a t1 p1)
       (NumRep a t2 p2)
       (!= t1 t2))
      ((delete (NumRep a t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Refl a) (Null))))
       (EqProof t2 t1 (Congruence (Cons (Refl a) (Null))))))

(rule ((VarRep a t1 p1)
       (VarRep a t2 p2)
       (!= t1 t2))
      ((panic "Variables should have a unique representation")))

(rule ((FmaRep x y z t1 p1)      
       (FmaRep x y z t2 p2)
       (!= t1 t2)
       (= x1-ast (Child1 t1))
       (= y1-ast (Child2 t1))
       (= z1-ast (Child3 t1))
       (= x2-ast (Child1 t2))
       (= y2-ast (Child2 t2))
       (= z2-ast (Child3 t2)))
      ((delete (FmaRep x y z t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1-ast x2-ast)
                                  (Cons (Equality y1-ast y2-ast)
                                  (Cons (Equality z1-ast z2-ast) Null)))))
       (EqProof t2 t1 (Congruence (Cons (Equality x1-ast x2-ast)
                                  (Cons (Equality y1-ast y2-ast)
                                  (Cons (Equality z1-ast z2-ast) Null)))))))
(rule ((IfRep x y z t1 p1)                                  
       (IfRep x y z t2 p2)
       (!= t1 t2)
       (= x1-ast (Child1 t1))
       (= y1-ast (Child2 t1))
       (= z1-ast (Child3 t1))
       (= x2-ast (Child1 t2))
       (= y2-ast (Child2 t2))
       (= z2-ast (Child3 t2)))
      ((delete (IfRep x y z t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1-ast x2-ast)
                                  (Cons (Equality y1-ast y2-ast)
                                  (Cons (Equality z1-ast z2-ast) Null)))))
       (EqProof t2 t1 (Congruence (Cons (Equality x1-ast x2-ast)
                                  (Cons (Equality y1-ast y2-ast)
                                  (Cons (Equality z1-ast z2-ast) Null)))))))

(rule ((NotEqRep x y t1 p1)                             
       (NotEqRep x y t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= y1 (Child2  t1))
       (= x2 (Child1 t2))
       (= y2 (Child2  t2)))
      ((delete (NotEqRep x y t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))))

(rule ((AddRep x y t1 p1)                             
       (AddRep x y t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= y1 (Child2  t1))
       (= x2 (Child1 t2))
       (= y2 (Child2  t2)))
      ((delete (AddRep x y t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))))

(rule ((SubRep x y t1 p1)                             
       (SubRep x y t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= y1 (Child2  t1))
       (= x2 (Child1 t2))
       (= y2 (Child2  t2)))
      ((delete (SubRep x y t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))))

(rule ((MulRep x y t1 p1)                             
       (MulRep x y t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= y1 (Child2  t1))
       (= x2 (Child1 t2))
       (= y2 (Child2  t2)))
      ((delete (MulRep x y t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))))

(rule ((DivRep x y t1 p1)                             
       (DivRep x y t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= y1 (Child2  t1))
       (= x2 (Child1 t2))
       (= y2 (Child2  t2)))
      ((delete (DivRep x y t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) (Cons (Equality y1 y2) Null))))))

(rule ((NegRep x t1 p1)
       (NegRep x t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= x2 (Child1 t2)))
      ((delete (NegRep x t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) Null)))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) Null)))))

(rule ((ExpRep x t1 p1)
       (ExpRep x t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= x2 (Child1 t2)))
      ((delete (ExpRep x t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) Null)))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) Null)))))

(rule ((Expm1Rep x t1 p1)
       (Expm1Rep x t2 p2)
       (!= t1 t2)
       (= x1 (Child1 t1))
       (= x2 (Child1 t2)))
      ((delete (Expm1Rep x t2 p2))
       (EqProof t1 t2 (Congruence (Cons (Equality x1 x2) Null)))
       (EqProof t2 t1 (Congruence (Cons (Equality x1 x2) Null)))))

(define eggvar1ast (DivAst (Expm1Ast (AddAst (VarAst "h0") (VarAst "h0"))) (Expm1Ast (VarAst "h0"))) :cost 10000000)

(set (VarRep_ "h0") (Pair (VarAst "h0") (Original (VarAst "h0"))))
(set (Expm1Rep_ (Var "h0")) (Pair (Expm1Ast (VarAst "h0")) (Original (Expm1Ast (VarAst "h0")))))
(set (AddRep_ (Var "h0") (Var "h0")) 
  (Pair           (AddAst (VarAst "h0") (VarAst "h0"))
        (Original (AddAst (VarAst "h0") (VarAst "h0")))))
(set (Expm1Rep_  (Add (Var "h0") (Var "h0")))
  (Pair           (Expm1Ast (AddAst (VarAst "h0") (VarAst "h0")))
        (Original (Expm1Ast (AddAst (VarAst "h0") (VarAst "h0"))))))
(set (DivRep_ (Expm1 (Add (Var "h0") (Var "h0"))) (Expm1 (Var "h0"))) (Pair eggvar1ast (Original eggvar1ast)))

(define eggvar1 (Div (Expm1 (Add (Var "h0") (Var "h0"))) (Expm1 (Var "h0"))) :cost 10000000)

(run 12)
(print unsound)